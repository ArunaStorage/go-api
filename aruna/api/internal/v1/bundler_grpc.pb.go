// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: aruna/api/internal/v1/bundler.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InternalBundlerServiceClient is the client API for InternalBundlerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InternalBundlerServiceClient interface {
	PrepareBundle(ctx context.Context, in *PrepareBundleRequest, opts ...grpc.CallOption) (*PrepareBundleResponse, error)
	EnableBundle(ctx context.Context, in *EnableBundleRequest, opts ...grpc.CallOption) (*EnableBundleResponse, error)
	InvalidateBundle(ctx context.Context, in *InvalidateBundleRequest, opts ...grpc.CallOption) (*InvalidateBundleResponse, error)
}

type internalBundlerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalBundlerServiceClient(cc grpc.ClientConnInterface) InternalBundlerServiceClient {
	return &internalBundlerServiceClient{cc}
}

func (c *internalBundlerServiceClient) PrepareBundle(ctx context.Context, in *PrepareBundleRequest, opts ...grpc.CallOption) (*PrepareBundleResponse, error) {
	out := new(PrepareBundleResponse)
	err := c.cc.Invoke(ctx, "/aruna.api.internal.v1.InternalBundlerService/PrepareBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalBundlerServiceClient) EnableBundle(ctx context.Context, in *EnableBundleRequest, opts ...grpc.CallOption) (*EnableBundleResponse, error) {
	out := new(EnableBundleResponse)
	err := c.cc.Invoke(ctx, "/aruna.api.internal.v1.InternalBundlerService/EnableBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalBundlerServiceClient) InvalidateBundle(ctx context.Context, in *InvalidateBundleRequest, opts ...grpc.CallOption) (*InvalidateBundleResponse, error) {
	out := new(InvalidateBundleResponse)
	err := c.cc.Invoke(ctx, "/aruna.api.internal.v1.InternalBundlerService/InvalidateBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalBundlerServiceServer is the server API for InternalBundlerService service.
// All implementations should embed UnimplementedInternalBundlerServiceServer
// for forward compatibility
type InternalBundlerServiceServer interface {
	PrepareBundle(context.Context, *PrepareBundleRequest) (*PrepareBundleResponse, error)
	EnableBundle(context.Context, *EnableBundleRequest) (*EnableBundleResponse, error)
	InvalidateBundle(context.Context, *InvalidateBundleRequest) (*InvalidateBundleResponse, error)
}

// UnimplementedInternalBundlerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedInternalBundlerServiceServer struct {
}

func (UnimplementedInternalBundlerServiceServer) PrepareBundle(context.Context, *PrepareBundleRequest) (*PrepareBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareBundle not implemented")
}
func (UnimplementedInternalBundlerServiceServer) EnableBundle(context.Context, *EnableBundleRequest) (*EnableBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableBundle not implemented")
}
func (UnimplementedInternalBundlerServiceServer) InvalidateBundle(context.Context, *InvalidateBundleRequest) (*InvalidateBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvalidateBundle not implemented")
}

// UnsafeInternalBundlerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalBundlerServiceServer will
// result in compilation errors.
type UnsafeInternalBundlerServiceServer interface {
	mustEmbedUnimplementedInternalBundlerServiceServer()
}

func RegisterInternalBundlerServiceServer(s grpc.ServiceRegistrar, srv InternalBundlerServiceServer) {
	s.RegisterService(&InternalBundlerService_ServiceDesc, srv)
}

func _InternalBundlerService_PrepareBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalBundlerServiceServer).PrepareBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aruna.api.internal.v1.InternalBundlerService/PrepareBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalBundlerServiceServer).PrepareBundle(ctx, req.(*PrepareBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalBundlerService_EnableBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalBundlerServiceServer).EnableBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aruna.api.internal.v1.InternalBundlerService/EnableBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalBundlerServiceServer).EnableBundle(ctx, req.(*EnableBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalBundlerService_InvalidateBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvalidateBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalBundlerServiceServer).InvalidateBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aruna.api.internal.v1.InternalBundlerService/InvalidateBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalBundlerServiceServer).InvalidateBundle(ctx, req.(*InvalidateBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InternalBundlerService_ServiceDesc is the grpc.ServiceDesc for InternalBundlerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InternalBundlerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.internal.v1.InternalBundlerService",
	HandlerType: (*InternalBundlerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PrepareBundle",
			Handler:    _InternalBundlerService_PrepareBundle_Handler,
		},
		{
			MethodName: "EnableBundle",
			Handler:    _InternalBundlerService_EnableBundle_Handler,
		},
		{
			MethodName: "InvalidateBundle",
			Handler:    _InternalBundlerService_InvalidateBundle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aruna/api/internal/v1/bundler.proto",
}

// InternalBundlerBackchannelServiceClient is the client API for InternalBundlerBackchannelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InternalBundlerBackchannelServiceClient interface {
	GetBundles(ctx context.Context, in *GetBundlesRequest, opts ...grpc.CallOption) (*GetBundlesResponse, error)
}

type internalBundlerBackchannelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalBundlerBackchannelServiceClient(cc grpc.ClientConnInterface) InternalBundlerBackchannelServiceClient {
	return &internalBundlerBackchannelServiceClient{cc}
}

func (c *internalBundlerBackchannelServiceClient) GetBundles(ctx context.Context, in *GetBundlesRequest, opts ...grpc.CallOption) (*GetBundlesResponse, error) {
	out := new(GetBundlesResponse)
	err := c.cc.Invoke(ctx, "/aruna.api.internal.v1.InternalBundlerBackchannelService/GetBundles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalBundlerBackchannelServiceServer is the server API for InternalBundlerBackchannelService service.
// All implementations should embed UnimplementedInternalBundlerBackchannelServiceServer
// for forward compatibility
type InternalBundlerBackchannelServiceServer interface {
	GetBundles(context.Context, *GetBundlesRequest) (*GetBundlesResponse, error)
}

// UnimplementedInternalBundlerBackchannelServiceServer should be embedded to have forward compatible implementations.
type UnimplementedInternalBundlerBackchannelServiceServer struct {
}

func (UnimplementedInternalBundlerBackchannelServiceServer) GetBundles(context.Context, *GetBundlesRequest) (*GetBundlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBundles not implemented")
}

// UnsafeInternalBundlerBackchannelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalBundlerBackchannelServiceServer will
// result in compilation errors.
type UnsafeInternalBundlerBackchannelServiceServer interface {
	mustEmbedUnimplementedInternalBundlerBackchannelServiceServer()
}

func RegisterInternalBundlerBackchannelServiceServer(s grpc.ServiceRegistrar, srv InternalBundlerBackchannelServiceServer) {
	s.RegisterService(&InternalBundlerBackchannelService_ServiceDesc, srv)
}

func _InternalBundlerBackchannelService_GetBundles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBundlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalBundlerBackchannelServiceServer).GetBundles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aruna.api.internal.v1.InternalBundlerBackchannelService/GetBundles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalBundlerBackchannelServiceServer).GetBundles(ctx, req.(*GetBundlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InternalBundlerBackchannelService_ServiceDesc is the grpc.ServiceDesc for InternalBundlerBackchannelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InternalBundlerBackchannelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.internal.v1.InternalBundlerBackchannelService",
	HandlerType: (*InternalBundlerBackchannelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBundles",
			Handler:    _InternalBundlerBackchannelService_GetBundles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aruna/api/internal/v1/bundler.proto",
}

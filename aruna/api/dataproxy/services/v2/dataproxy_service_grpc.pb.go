// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: aruna/api/dataproxy/services/v2/dataproxy_service.proto

package v2

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	DataproxyReplicationService_PullReplication_FullMethodName = "/aruna.api.dataproxy.services.v2.DataproxyReplicationService/PullReplication"
	DataproxyReplicationService_PushReplication_FullMethodName = "/aruna.api.dataproxy.services.v2.DataproxyReplicationService/PushReplication"
)

// DataproxyReplicationServiceClient is the client API for DataproxyReplicationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataproxyReplicationServiceClient interface {
	// RequestReplication
	//
	// Status: ALPHA
	//
	// Creates a replication stream
	PullReplication(ctx context.Context, opts ...grpc.CallOption) (DataproxyReplicationService_PullReplicationClient, error)
	// InitReplication
	//
	// Status: UNIMPLEMENTED
	//
	// Provides the necessary url to init replication
	PushReplication(ctx context.Context, in *PushReplicationRequest, opts ...grpc.CallOption) (*PushReplicationResponse, error)
}

type dataproxyReplicationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataproxyReplicationServiceClient(cc grpc.ClientConnInterface) DataproxyReplicationServiceClient {
	return &dataproxyReplicationServiceClient{cc}
}

func (c *dataproxyReplicationServiceClient) PullReplication(ctx context.Context, opts ...grpc.CallOption) (DataproxyReplicationService_PullReplicationClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataproxyReplicationService_ServiceDesc.Streams[0], DataproxyReplicationService_PullReplication_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &dataproxyReplicationServicePullReplicationClient{stream}
	return x, nil
}

type DataproxyReplicationService_PullReplicationClient interface {
	Send(*PullReplicationRequest) error
	Recv() (*PullReplicationResponse, error)
	grpc.ClientStream
}

type dataproxyReplicationServicePullReplicationClient struct {
	grpc.ClientStream
}

func (x *dataproxyReplicationServicePullReplicationClient) Send(m *PullReplicationRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataproxyReplicationServicePullReplicationClient) Recv() (*PullReplicationResponse, error) {
	m := new(PullReplicationResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataproxyReplicationServiceClient) PushReplication(ctx context.Context, in *PushReplicationRequest, opts ...grpc.CallOption) (*PushReplicationResponse, error) {
	out := new(PushReplicationResponse)
	err := c.cc.Invoke(ctx, DataproxyReplicationService_PushReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataproxyReplicationServiceServer is the server API for DataproxyReplicationService service.
// All implementations should embed UnimplementedDataproxyReplicationServiceServer
// for forward compatibility
type DataproxyReplicationServiceServer interface {
	// RequestReplication
	//
	// Status: ALPHA
	//
	// Creates a replication stream
	PullReplication(DataproxyReplicationService_PullReplicationServer) error
	// InitReplication
	//
	// Status: UNIMPLEMENTED
	//
	// Provides the necessary url to init replication
	PushReplication(context.Context, *PushReplicationRequest) (*PushReplicationResponse, error)
}

// UnimplementedDataproxyReplicationServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDataproxyReplicationServiceServer struct {
}

func (UnimplementedDataproxyReplicationServiceServer) PullReplication(DataproxyReplicationService_PullReplicationServer) error {
	return status.Errorf(codes.Unimplemented, "method PullReplication not implemented")
}
func (UnimplementedDataproxyReplicationServiceServer) PushReplication(context.Context, *PushReplicationRequest) (*PushReplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushReplication not implemented")
}

// UnsafeDataproxyReplicationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataproxyReplicationServiceServer will
// result in compilation errors.
type UnsafeDataproxyReplicationServiceServer interface {
	mustEmbedUnimplementedDataproxyReplicationServiceServer()
}

func RegisterDataproxyReplicationServiceServer(s grpc.ServiceRegistrar, srv DataproxyReplicationServiceServer) {
	s.RegisterService(&DataproxyReplicationService_ServiceDesc, srv)
}

func _DataproxyReplicationService_PullReplication_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataproxyReplicationServiceServer).PullReplication(&dataproxyReplicationServicePullReplicationServer{stream})
}

type DataproxyReplicationService_PullReplicationServer interface {
	Send(*PullReplicationResponse) error
	Recv() (*PullReplicationRequest, error)
	grpc.ServerStream
}

type dataproxyReplicationServicePullReplicationServer struct {
	grpc.ServerStream
}

func (x *dataproxyReplicationServicePullReplicationServer) Send(m *PullReplicationResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataproxyReplicationServicePullReplicationServer) Recv() (*PullReplicationRequest, error) {
	m := new(PullReplicationRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataproxyReplicationService_PushReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyReplicationServiceServer).PushReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyReplicationService_PushReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyReplicationServiceServer).PushReplication(ctx, req.(*PushReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataproxyReplicationService_ServiceDesc is the grpc.ServiceDesc for DataproxyReplicationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataproxyReplicationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.dataproxy.services.v2.DataproxyReplicationService",
	HandlerType: (*DataproxyReplicationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushReplication",
			Handler:    _DataproxyReplicationService_PushReplication_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PullReplication",
			Handler:       _DataproxyReplicationService_PullReplication_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "aruna/api/dataproxy/services/v2/dataproxy_service.proto",
}

const (
	DataproxyBackendService_PutObject_FullMethodName               = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/PutObject"
	DataproxyBackendService_GetObject_FullMethodName               = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/GetObject"
	DataproxyBackendService_HeadObject_FullMethodName              = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/HeadObject"
	DataproxyBackendService_InitMultiPartUpload_FullMethodName     = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/InitMultiPartUpload"
	DataproxyBackendService_UploadPart_FullMethodName              = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/UploadPart"
	DataproxyBackendService_CompleteMultiPartUpload_FullMethodName = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/CompleteMultiPartUpload"
	DataproxyBackendService_CreateBucket_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/CreateBucket"
	DataproxyBackendService_DeleteBucket_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/DeleteBucket"
	DataproxyBackendService_DeleteObject_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/DeleteObject"
	DataproxyBackendService_InitLocation_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/InitLocation"
)

// DataproxyBackendServiceClient is the client API for DataproxyBackendService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataproxyBackendServiceClient interface {
	PutObject(ctx context.Context, opts ...grpc.CallOption) (DataproxyBackendService_PutObjectClient, error)
	GetObject(ctx context.Context, in *GetObjectRequest, opts ...grpc.CallOption) (DataproxyBackendService_GetObjectClient, error)
	HeadObject(ctx context.Context, in *HeadObjectRequest, opts ...grpc.CallOption) (*HeadObjectResponse, error)
	InitMultiPartUpload(ctx context.Context, in *InitMultiPartUploadRequest, opts ...grpc.CallOption) (*InitMultiPartUploadResponse, error)
	UploadPart(ctx context.Context, opts ...grpc.CallOption) (DataproxyBackendService_UploadPartClient, error)
	CompleteMultiPartUpload(ctx context.Context, in *CompleteMultiPartUploadRequest, opts ...grpc.CallOption) (*CompleteMultiPartUploadResponse, error)
	CreateBucket(ctx context.Context, in *CreateBucketRequest, opts ...grpc.CallOption) (*CreateBucketResponse, error)
	DeleteBucket(ctx context.Context, in *DeleteBucketRequest, opts ...grpc.CallOption) (*DeleteBucketResponse, error)
	DeleteObject(ctx context.Context, in *DeleteObjectRequest, opts ...grpc.CallOption) (*DeleteObjectResponse, error)
	InitLocation(ctx context.Context, in *InitLocationRequest, opts ...grpc.CallOption) (*InitLocationResponse, error)
}

type dataproxyBackendServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataproxyBackendServiceClient(cc grpc.ClientConnInterface) DataproxyBackendServiceClient {
	return &dataproxyBackendServiceClient{cc}
}

func (c *dataproxyBackendServiceClient) PutObject(ctx context.Context, opts ...grpc.CallOption) (DataproxyBackendService_PutObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataproxyBackendService_ServiceDesc.Streams[0], DataproxyBackendService_PutObject_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &dataproxyBackendServicePutObjectClient{stream}
	return x, nil
}

type DataproxyBackendService_PutObjectClient interface {
	Send(*PutObjectRequest) error
	CloseAndRecv() (*PutObjectResponse, error)
	grpc.ClientStream
}

type dataproxyBackendServicePutObjectClient struct {
	grpc.ClientStream
}

func (x *dataproxyBackendServicePutObjectClient) Send(m *PutObjectRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataproxyBackendServicePutObjectClient) CloseAndRecv() (*PutObjectResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutObjectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataproxyBackendServiceClient) GetObject(ctx context.Context, in *GetObjectRequest, opts ...grpc.CallOption) (DataproxyBackendService_GetObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataproxyBackendService_ServiceDesc.Streams[1], DataproxyBackendService_GetObject_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &dataproxyBackendServiceGetObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataproxyBackendService_GetObjectClient interface {
	Recv() (*GetObjectResponse, error)
	grpc.ClientStream
}

type dataproxyBackendServiceGetObjectClient struct {
	grpc.ClientStream
}

func (x *dataproxyBackendServiceGetObjectClient) Recv() (*GetObjectResponse, error) {
	m := new(GetObjectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataproxyBackendServiceClient) HeadObject(ctx context.Context, in *HeadObjectRequest, opts ...grpc.CallOption) (*HeadObjectResponse, error) {
	out := new(HeadObjectResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_HeadObject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) InitMultiPartUpload(ctx context.Context, in *InitMultiPartUploadRequest, opts ...grpc.CallOption) (*InitMultiPartUploadResponse, error) {
	out := new(InitMultiPartUploadResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_InitMultiPartUpload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) UploadPart(ctx context.Context, opts ...grpc.CallOption) (DataproxyBackendService_UploadPartClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataproxyBackendService_ServiceDesc.Streams[2], DataproxyBackendService_UploadPart_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &dataproxyBackendServiceUploadPartClient{stream}
	return x, nil
}

type DataproxyBackendService_UploadPartClient interface {
	Send(*UploadPartRequest) error
	CloseAndRecv() (*UploadPartResponse, error)
	grpc.ClientStream
}

type dataproxyBackendServiceUploadPartClient struct {
	grpc.ClientStream
}

func (x *dataproxyBackendServiceUploadPartClient) Send(m *UploadPartRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataproxyBackendServiceUploadPartClient) CloseAndRecv() (*UploadPartResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadPartResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataproxyBackendServiceClient) CompleteMultiPartUpload(ctx context.Context, in *CompleteMultiPartUploadRequest, opts ...grpc.CallOption) (*CompleteMultiPartUploadResponse, error) {
	out := new(CompleteMultiPartUploadResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_CompleteMultiPartUpload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) CreateBucket(ctx context.Context, in *CreateBucketRequest, opts ...grpc.CallOption) (*CreateBucketResponse, error) {
	out := new(CreateBucketResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_CreateBucket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) DeleteBucket(ctx context.Context, in *DeleteBucketRequest, opts ...grpc.CallOption) (*DeleteBucketResponse, error) {
	out := new(DeleteBucketResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_DeleteBucket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) DeleteObject(ctx context.Context, in *DeleteObjectRequest, opts ...grpc.CallOption) (*DeleteObjectResponse, error) {
	out := new(DeleteObjectResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_DeleteObject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) InitLocation(ctx context.Context, in *InitLocationRequest, opts ...grpc.CallOption) (*InitLocationResponse, error) {
	out := new(InitLocationResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_InitLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataproxyBackendServiceServer is the server API for DataproxyBackendService service.
// All implementations should embed UnimplementedDataproxyBackendServiceServer
// for forward compatibility
type DataproxyBackendServiceServer interface {
	PutObject(DataproxyBackendService_PutObjectServer) error
	GetObject(*GetObjectRequest, DataproxyBackendService_GetObjectServer) error
	HeadObject(context.Context, *HeadObjectRequest) (*HeadObjectResponse, error)
	InitMultiPartUpload(context.Context, *InitMultiPartUploadRequest) (*InitMultiPartUploadResponse, error)
	UploadPart(DataproxyBackendService_UploadPartServer) error
	CompleteMultiPartUpload(context.Context, *CompleteMultiPartUploadRequest) (*CompleteMultiPartUploadResponse, error)
	CreateBucket(context.Context, *CreateBucketRequest) (*CreateBucketResponse, error)
	DeleteBucket(context.Context, *DeleteBucketRequest) (*DeleteBucketResponse, error)
	DeleteObject(context.Context, *DeleteObjectRequest) (*DeleteObjectResponse, error)
	InitLocation(context.Context, *InitLocationRequest) (*InitLocationResponse, error)
}

// UnimplementedDataproxyBackendServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDataproxyBackendServiceServer struct {
}

func (UnimplementedDataproxyBackendServiceServer) PutObject(DataproxyBackendService_PutObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method PutObject not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) GetObject(*GetObjectRequest, DataproxyBackendService_GetObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method GetObject not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) HeadObject(context.Context, *HeadObjectRequest) (*HeadObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeadObject not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) InitMultiPartUpload(context.Context, *InitMultiPartUploadRequest) (*InitMultiPartUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitMultiPartUpload not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) UploadPart(DataproxyBackendService_UploadPartServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadPart not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) CompleteMultiPartUpload(context.Context, *CompleteMultiPartUploadRequest) (*CompleteMultiPartUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteMultiPartUpload not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) CreateBucket(context.Context, *CreateBucketRequest) (*CreateBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBucket not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) DeleteBucket(context.Context, *DeleteBucketRequest) (*DeleteBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBucket not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) DeleteObject(context.Context, *DeleteObjectRequest) (*DeleteObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteObject not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) InitLocation(context.Context, *InitLocationRequest) (*InitLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitLocation not implemented")
}

// UnsafeDataproxyBackendServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataproxyBackendServiceServer will
// result in compilation errors.
type UnsafeDataproxyBackendServiceServer interface {
	mustEmbedUnimplementedDataproxyBackendServiceServer()
}

func RegisterDataproxyBackendServiceServer(s grpc.ServiceRegistrar, srv DataproxyBackendServiceServer) {
	s.RegisterService(&DataproxyBackendService_ServiceDesc, srv)
}

func _DataproxyBackendService_PutObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataproxyBackendServiceServer).PutObject(&dataproxyBackendServicePutObjectServer{stream})
}

type DataproxyBackendService_PutObjectServer interface {
	SendAndClose(*PutObjectResponse) error
	Recv() (*PutObjectRequest, error)
	grpc.ServerStream
}

type dataproxyBackendServicePutObjectServer struct {
	grpc.ServerStream
}

func (x *dataproxyBackendServicePutObjectServer) SendAndClose(m *PutObjectResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataproxyBackendServicePutObjectServer) Recv() (*PutObjectRequest, error) {
	m := new(PutObjectRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataproxyBackendService_GetObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetObjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataproxyBackendServiceServer).GetObject(m, &dataproxyBackendServiceGetObjectServer{stream})
}

type DataproxyBackendService_GetObjectServer interface {
	Send(*GetObjectResponse) error
	grpc.ServerStream
}

type dataproxyBackendServiceGetObjectServer struct {
	grpc.ServerStream
}

func (x *dataproxyBackendServiceGetObjectServer) Send(m *GetObjectResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DataproxyBackendService_HeadObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeadObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).HeadObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_HeadObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).HeadObject(ctx, req.(*HeadObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_InitMultiPartUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitMultiPartUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).InitMultiPartUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_InitMultiPartUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).InitMultiPartUpload(ctx, req.(*InitMultiPartUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_UploadPart_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataproxyBackendServiceServer).UploadPart(&dataproxyBackendServiceUploadPartServer{stream})
}

type DataproxyBackendService_UploadPartServer interface {
	SendAndClose(*UploadPartResponse) error
	Recv() (*UploadPartRequest, error)
	grpc.ServerStream
}

type dataproxyBackendServiceUploadPartServer struct {
	grpc.ServerStream
}

func (x *dataproxyBackendServiceUploadPartServer) SendAndClose(m *UploadPartResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataproxyBackendServiceUploadPartServer) Recv() (*UploadPartRequest, error) {
	m := new(UploadPartRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataproxyBackendService_CompleteMultiPartUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteMultiPartUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).CompleteMultiPartUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_CompleteMultiPartUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).CompleteMultiPartUpload(ctx, req.(*CompleteMultiPartUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_CreateBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).CreateBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_CreateBucket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).CreateBucket(ctx, req.(*CreateBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_DeleteBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).DeleteBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_DeleteBucket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).DeleteBucket(ctx, req.(*DeleteBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_DeleteObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).DeleteObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_DeleteObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).DeleteObject(ctx, req.(*DeleteObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_InitLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).InitLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_InitLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).InitLocation(ctx, req.(*InitLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataproxyBackendService_ServiceDesc is the grpc.ServiceDesc for DataproxyBackendService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataproxyBackendService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.dataproxy.services.v2.DataproxyBackendService",
	HandlerType: (*DataproxyBackendServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HeadObject",
			Handler:    _DataproxyBackendService_HeadObject_Handler,
		},
		{
			MethodName: "InitMultiPartUpload",
			Handler:    _DataproxyBackendService_InitMultiPartUpload_Handler,
		},
		{
			MethodName: "CompleteMultiPartUpload",
			Handler:    _DataproxyBackendService_CompleteMultiPartUpload_Handler,
		},
		{
			MethodName: "CreateBucket",
			Handler:    _DataproxyBackendService_CreateBucket_Handler,
		},
		{
			MethodName: "DeleteBucket",
			Handler:    _DataproxyBackendService_DeleteBucket_Handler,
		},
		{
			MethodName: "DeleteObject",
			Handler:    _DataproxyBackendService_DeleteObject_Handler,
		},
		{
			MethodName: "InitLocation",
			Handler:    _DataproxyBackendService_InitLocation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutObject",
			Handler:       _DataproxyBackendService_PutObject_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetObject",
			Handler:       _DataproxyBackendService_GetObject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UploadPart",
			Handler:       _DataproxyBackendService_UploadPart_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "aruna/api/dataproxy/services/v2/dataproxy_service.proto",
}

const (
	DataproxyUserService_GetCredentials_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyUserService/GetCredentials"
	DataproxyUserService_CreateOrUpdateCredentials_FullMethodName = "/aruna.api.dataproxy.services.v2.DataproxyUserService/CreateOrUpdateCredentials"
	DataproxyUserService_RevokeCredentials_FullMethodName         = "/aruna.api.dataproxy.services.v2.DataproxyUserService/RevokeCredentials"
	DataproxyUserService_PushReplica_FullMethodName               = "/aruna.api.dataproxy.services.v2.DataproxyUserService/PushReplica"
	DataproxyUserService_PullReplica_FullMethodName               = "/aruna.api.dataproxy.services.v2.DataproxyUserService/PullReplica"
	DataproxyUserService_ReplicationStatus_FullMethodName         = "/aruna.api.dataproxy.services.v2.DataproxyUserService/ReplicationStatus"
)

// DataproxyUserServiceClient is the client API for DataproxyUserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataproxyUserServiceClient interface {
	// GetCredentials
	//
	// Status: BETA
	//
	// Authorized method that needs a aruna-token to exchange for dataproxy
	// specific S3AccessKey and S3SecretKey
	GetCredentials(ctx context.Context, in *GetCredentialsRequest, opts ...grpc.CallOption) (*GetCredentialsResponse, error)
	// CreateOrUpdateCredentials
	//
	// Status: BETA
	//
	// Authorized method that needs a aruna-token to exchange for dataproxy
	// specific S3AccessKey and S3SecretKey
	CreateOrUpdateCredentials(ctx context.Context, in *CreateOrUpdateCredentialsRequest, opts ...grpc.CallOption) (*CreateOrUpdateCredentialsResponse, error)
	// RevokeCredentials
	//
	// Status: BETA
	//
	// Authorized method that needs a aruna-token
	// Revokes the current credentials
	RevokeCredentials(ctx context.Context, in *RevokeCredentialsRequest, opts ...grpc.CallOption) (*RevokeCredentialsResponse, error)
	// PushReplica
	//
	// Status: UNIMPLEMENTED
	//
	// Manually transfers a replica to another data-proxy
	PushReplica(ctx context.Context, in *PushReplicaRequest, opts ...grpc.CallOption) (*PushReplicaResponse, error)
	// PullReplica
	//
	// Status: UNIMPLEMENTED
	//
	// Manually request data to be transferred to this data-proxy
	PullReplica(ctx context.Context, in *PullReplicaRequest, opts ...grpc.CallOption) (*PullReplicaResponse, error)
	// ReplicationStatus
	//
	// Status: UNIMPLEMENTED
	//
	// Status of the previous replication request
	ReplicationStatus(ctx context.Context, in *ReplicationStatusRequest, opts ...grpc.CallOption) (*ReplicationStatusResponse, error)
}

type dataproxyUserServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataproxyUserServiceClient(cc grpc.ClientConnInterface) DataproxyUserServiceClient {
	return &dataproxyUserServiceClient{cc}
}

func (c *dataproxyUserServiceClient) GetCredentials(ctx context.Context, in *GetCredentialsRequest, opts ...grpc.CallOption) (*GetCredentialsResponse, error) {
	out := new(GetCredentialsResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_GetCredentials_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyUserServiceClient) CreateOrUpdateCredentials(ctx context.Context, in *CreateOrUpdateCredentialsRequest, opts ...grpc.CallOption) (*CreateOrUpdateCredentialsResponse, error) {
	out := new(CreateOrUpdateCredentialsResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_CreateOrUpdateCredentials_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyUserServiceClient) RevokeCredentials(ctx context.Context, in *RevokeCredentialsRequest, opts ...grpc.CallOption) (*RevokeCredentialsResponse, error) {
	out := new(RevokeCredentialsResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_RevokeCredentials_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyUserServiceClient) PushReplica(ctx context.Context, in *PushReplicaRequest, opts ...grpc.CallOption) (*PushReplicaResponse, error) {
	out := new(PushReplicaResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_PushReplica_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyUserServiceClient) PullReplica(ctx context.Context, in *PullReplicaRequest, opts ...grpc.CallOption) (*PullReplicaResponse, error) {
	out := new(PullReplicaResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_PullReplica_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyUserServiceClient) ReplicationStatus(ctx context.Context, in *ReplicationStatusRequest, opts ...grpc.CallOption) (*ReplicationStatusResponse, error) {
	out := new(ReplicationStatusResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_ReplicationStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataproxyUserServiceServer is the server API for DataproxyUserService service.
// All implementations should embed UnimplementedDataproxyUserServiceServer
// for forward compatibility
type DataproxyUserServiceServer interface {
	// GetCredentials
	//
	// Status: BETA
	//
	// Authorized method that needs a aruna-token to exchange for dataproxy
	// specific S3AccessKey and S3SecretKey
	GetCredentials(context.Context, *GetCredentialsRequest) (*GetCredentialsResponse, error)
	// CreateOrUpdateCredentials
	//
	// Status: BETA
	//
	// Authorized method that needs a aruna-token to exchange for dataproxy
	// specific S3AccessKey and S3SecretKey
	CreateOrUpdateCredentials(context.Context, *CreateOrUpdateCredentialsRequest) (*CreateOrUpdateCredentialsResponse, error)
	// RevokeCredentials
	//
	// Status: BETA
	//
	// Authorized method that needs a aruna-token
	// Revokes the current credentials
	RevokeCredentials(context.Context, *RevokeCredentialsRequest) (*RevokeCredentialsResponse, error)
	// PushReplica
	//
	// Status: UNIMPLEMENTED
	//
	// Manually transfers a replica to another data-proxy
	PushReplica(context.Context, *PushReplicaRequest) (*PushReplicaResponse, error)
	// PullReplica
	//
	// Status: UNIMPLEMENTED
	//
	// Manually request data to be transferred to this data-proxy
	PullReplica(context.Context, *PullReplicaRequest) (*PullReplicaResponse, error)
	// ReplicationStatus
	//
	// Status: UNIMPLEMENTED
	//
	// Status of the previous replication request
	ReplicationStatus(context.Context, *ReplicationStatusRequest) (*ReplicationStatusResponse, error)
}

// UnimplementedDataproxyUserServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDataproxyUserServiceServer struct {
}

func (UnimplementedDataproxyUserServiceServer) GetCredentials(context.Context, *GetCredentialsRequest) (*GetCredentialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCredentials not implemented")
}
func (UnimplementedDataproxyUserServiceServer) CreateOrUpdateCredentials(context.Context, *CreateOrUpdateCredentialsRequest) (*CreateOrUpdateCredentialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateCredentials not implemented")
}
func (UnimplementedDataproxyUserServiceServer) RevokeCredentials(context.Context, *RevokeCredentialsRequest) (*RevokeCredentialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeCredentials not implemented")
}
func (UnimplementedDataproxyUserServiceServer) PushReplica(context.Context, *PushReplicaRequest) (*PushReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushReplica not implemented")
}
func (UnimplementedDataproxyUserServiceServer) PullReplica(context.Context, *PullReplicaRequest) (*PullReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullReplica not implemented")
}
func (UnimplementedDataproxyUserServiceServer) ReplicationStatus(context.Context, *ReplicationStatusRequest) (*ReplicationStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplicationStatus not implemented")
}

// UnsafeDataproxyUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataproxyUserServiceServer will
// result in compilation errors.
type UnsafeDataproxyUserServiceServer interface {
	mustEmbedUnimplementedDataproxyUserServiceServer()
}

func RegisterDataproxyUserServiceServer(s grpc.ServiceRegistrar, srv DataproxyUserServiceServer) {
	s.RegisterService(&DataproxyUserService_ServiceDesc, srv)
}

func _DataproxyUserService_GetCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).GetCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_GetCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).GetCredentials(ctx, req.(*GetCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyUserService_CreateOrUpdateCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrUpdateCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).CreateOrUpdateCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_CreateOrUpdateCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).CreateOrUpdateCredentials(ctx, req.(*CreateOrUpdateCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyUserService_RevokeCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).RevokeCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_RevokeCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).RevokeCredentials(ctx, req.(*RevokeCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyUserService_PushReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).PushReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_PushReplica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).PushReplica(ctx, req.(*PushReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyUserService_PullReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).PullReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_PullReplica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).PullReplica(ctx, req.(*PullReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyUserService_ReplicationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).ReplicationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_ReplicationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).ReplicationStatus(ctx, req.(*ReplicationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataproxyUserService_ServiceDesc is the grpc.ServiceDesc for DataproxyUserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataproxyUserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.dataproxy.services.v2.DataproxyUserService",
	HandlerType: (*DataproxyUserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCredentials",
			Handler:    _DataproxyUserService_GetCredentials_Handler,
		},
		{
			MethodName: "CreateOrUpdateCredentials",
			Handler:    _DataproxyUserService_CreateOrUpdateCredentials_Handler,
		},
		{
			MethodName: "RevokeCredentials",
			Handler:    _DataproxyUserService_RevokeCredentials_Handler,
		},
		{
			MethodName: "PushReplica",
			Handler:    _DataproxyUserService_PushReplica_Handler,
		},
		{
			MethodName: "PullReplica",
			Handler:    _DataproxyUserService_PullReplica_Handler,
		},
		{
			MethodName: "ReplicationStatus",
			Handler:    _DataproxyUserService_ReplicationStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aruna/api/dataproxy/services/v2/dataproxy_service.proto",
}

const (
	DataproxyIngestionService_IngestExistingObject_FullMethodName = "/aruna.api.dataproxy.services.v2.DataproxyIngestionService/IngestExistingObject"
)

// DataproxyIngestionServiceClient is the client API for DataproxyIngestionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataproxyIngestionServiceClient interface {
	// IngestExistingObject
	//
	// Status: ALPHA
	//
	// Ingest an existing object into backend
	IngestExistingObject(ctx context.Context, in *IngestExistingObjectRequest, opts ...grpc.CallOption) (*IngestExistingObjectResponse, error)
}

type dataproxyIngestionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataproxyIngestionServiceClient(cc grpc.ClientConnInterface) DataproxyIngestionServiceClient {
	return &dataproxyIngestionServiceClient{cc}
}

func (c *dataproxyIngestionServiceClient) IngestExistingObject(ctx context.Context, in *IngestExistingObjectRequest, opts ...grpc.CallOption) (*IngestExistingObjectResponse, error) {
	out := new(IngestExistingObjectResponse)
	err := c.cc.Invoke(ctx, DataproxyIngestionService_IngestExistingObject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataproxyIngestionServiceServer is the server API for DataproxyIngestionService service.
// All implementations should embed UnimplementedDataproxyIngestionServiceServer
// for forward compatibility
type DataproxyIngestionServiceServer interface {
	// IngestExistingObject
	//
	// Status: ALPHA
	//
	// Ingest an existing object into backend
	IngestExistingObject(context.Context, *IngestExistingObjectRequest) (*IngestExistingObjectResponse, error)
}

// UnimplementedDataproxyIngestionServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDataproxyIngestionServiceServer struct {
}

func (UnimplementedDataproxyIngestionServiceServer) IngestExistingObject(context.Context, *IngestExistingObjectRequest) (*IngestExistingObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IngestExistingObject not implemented")
}

// UnsafeDataproxyIngestionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataproxyIngestionServiceServer will
// result in compilation errors.
type UnsafeDataproxyIngestionServiceServer interface {
	mustEmbedUnimplementedDataproxyIngestionServiceServer()
}

func RegisterDataproxyIngestionServiceServer(s grpc.ServiceRegistrar, srv DataproxyIngestionServiceServer) {
	s.RegisterService(&DataproxyIngestionService_ServiceDesc, srv)
}

func _DataproxyIngestionService_IngestExistingObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestExistingObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyIngestionServiceServer).IngestExistingObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyIngestionService_IngestExistingObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyIngestionServiceServer).IngestExistingObject(ctx, req.(*IngestExistingObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataproxyIngestionService_ServiceDesc is the grpc.ServiceDesc for DataproxyIngestionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataproxyIngestionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.dataproxy.services.v2.DataproxyIngestionService",
	HandlerType: (*DataproxyIngestionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IngestExistingObject",
			Handler:    _DataproxyIngestionService_IngestExistingObject_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aruna/api/dataproxy/services/v2/dataproxy_service.proto",
}

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: aruna/api/dataproxy/services/v2/dataproxy_service.proto

package v2

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	DataproxyService_RequestReplication_FullMethodName = "/aruna.api.dataproxy.services.v2.DataproxyService/RequestReplication"
	DataproxyService_InitReplication_FullMethodName    = "/aruna.api.dataproxy.services.v2.DataproxyService/InitReplication"
)

// DataproxyServiceClient is the client API for DataproxyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataproxyServiceClient interface {
	// RequestReplication
	//
	// Status: ALPHA
	//
	// Creates a replication request
	RequestReplication(ctx context.Context, in *RequestReplicationRequest, opts ...grpc.CallOption) (*RequestReplicationResponse, error)
	// InitReplication
	//
	// Status: ALPHA
	//
	// Provides the necessary url to init replication
	InitReplication(ctx context.Context, in *InitReplicationRequest, opts ...grpc.CallOption) (*InitReplicationResponse, error)
}

type dataproxyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataproxyServiceClient(cc grpc.ClientConnInterface) DataproxyServiceClient {
	return &dataproxyServiceClient{cc}
}

func (c *dataproxyServiceClient) RequestReplication(ctx context.Context, in *RequestReplicationRequest, opts ...grpc.CallOption) (*RequestReplicationResponse, error) {
	out := new(RequestReplicationResponse)
	err := c.cc.Invoke(ctx, DataproxyService_RequestReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyServiceClient) InitReplication(ctx context.Context, in *InitReplicationRequest, opts ...grpc.CallOption) (*InitReplicationResponse, error) {
	out := new(InitReplicationResponse)
	err := c.cc.Invoke(ctx, DataproxyService_InitReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataproxyServiceServer is the server API for DataproxyService service.
// All implementations should embed UnimplementedDataproxyServiceServer
// for forward compatibility
type DataproxyServiceServer interface {
	// RequestReplication
	//
	// Status: ALPHA
	//
	// Creates a replication request
	RequestReplication(context.Context, *RequestReplicationRequest) (*RequestReplicationResponse, error)
	// InitReplication
	//
	// Status: ALPHA
	//
	// Provides the necessary url to init replication
	InitReplication(context.Context, *InitReplicationRequest) (*InitReplicationResponse, error)
}

// UnimplementedDataproxyServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDataproxyServiceServer struct {
}

func (UnimplementedDataproxyServiceServer) RequestReplication(context.Context, *RequestReplicationRequest) (*RequestReplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestReplication not implemented")
}
func (UnimplementedDataproxyServiceServer) InitReplication(context.Context, *InitReplicationRequest) (*InitReplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitReplication not implemented")
}

// UnsafeDataproxyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataproxyServiceServer will
// result in compilation errors.
type UnsafeDataproxyServiceServer interface {
	mustEmbedUnimplementedDataproxyServiceServer()
}

func RegisterDataproxyServiceServer(s grpc.ServiceRegistrar, srv DataproxyServiceServer) {
	s.RegisterService(&DataproxyService_ServiceDesc, srv)
}

func _DataproxyService_RequestReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyServiceServer).RequestReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyService_RequestReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyServiceServer).RequestReplication(ctx, req.(*RequestReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyService_InitReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyServiceServer).InitReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyService_InitReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyServiceServer).InitReplication(ctx, req.(*InitReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataproxyService_ServiceDesc is the grpc.ServiceDesc for DataproxyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataproxyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.dataproxy.services.v2.DataproxyService",
	HandlerType: (*DataproxyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestReplication",
			Handler:    _DataproxyService_RequestReplication_Handler,
		},
		{
			MethodName: "InitReplication",
			Handler:    _DataproxyService_InitReplication_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aruna/api/dataproxy/services/v2/dataproxy_service.proto",
}

const (
	DataproxyBackendService_PutObject_FullMethodName               = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/PutObject"
	DataproxyBackendService_GetObject_FullMethodName               = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/GetObject"
	DataproxyBackendService_HeadObject_FullMethodName              = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/HeadObject"
	DataproxyBackendService_InitMultiPartUpload_FullMethodName     = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/InitMultiPartUpload"
	DataproxyBackendService_UploadPart_FullMethodName              = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/UploadPart"
	DataproxyBackendService_CompleteMultiPartUpload_FullMethodName = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/CompleteMultiPartUpload"
	DataproxyBackendService_CreateBucket_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/CreateBucket"
	DataproxyBackendService_DeleteBucket_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/DeleteBucket"
	DataproxyBackendService_DeleteObject_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/DeleteObject"
	DataproxyBackendService_InitLocation_FullMethodName            = "/aruna.api.dataproxy.services.v2.DataproxyBackendService/InitLocation"
)

// DataproxyBackendServiceClient is the client API for DataproxyBackendService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataproxyBackendServiceClient interface {
	PutObject(ctx context.Context, opts ...grpc.CallOption) (DataproxyBackendService_PutObjectClient, error)
	GetObject(ctx context.Context, in *GetObjectRequest, opts ...grpc.CallOption) (DataproxyBackendService_GetObjectClient, error)
	HeadObject(ctx context.Context, in *HeadObjectRequest, opts ...grpc.CallOption) (*HeadObjectResponse, error)
	InitMultiPartUpload(ctx context.Context, in *InitMultiPartUploadRequest, opts ...grpc.CallOption) (*InitMultiPartUploadResponse, error)
	UploadPart(ctx context.Context, opts ...grpc.CallOption) (DataproxyBackendService_UploadPartClient, error)
	CompleteMultiPartUpload(ctx context.Context, in *CompleteMultiPartUploadRequest, opts ...grpc.CallOption) (*CompleteMultiPartUploadResponse, error)
	CreateBucket(ctx context.Context, in *CreateBucketRequest, opts ...grpc.CallOption) (*CreateBucketResponse, error)
	DeleteBucket(ctx context.Context, in *DeleteBucketRequest, opts ...grpc.CallOption) (*DeleteBucketResponse, error)
	DeleteObject(ctx context.Context, in *DeleteObjectRequest, opts ...grpc.CallOption) (*DeleteObjectResponse, error)
	InitLocation(ctx context.Context, in *InitLocationRequest, opts ...grpc.CallOption) (*InitLocationResponse, error)
}

type dataproxyBackendServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataproxyBackendServiceClient(cc grpc.ClientConnInterface) DataproxyBackendServiceClient {
	return &dataproxyBackendServiceClient{cc}
}

func (c *dataproxyBackendServiceClient) PutObject(ctx context.Context, opts ...grpc.CallOption) (DataproxyBackendService_PutObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataproxyBackendService_ServiceDesc.Streams[0], DataproxyBackendService_PutObject_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &dataproxyBackendServicePutObjectClient{stream}
	return x, nil
}

type DataproxyBackendService_PutObjectClient interface {
	Send(*PutObjectRequest) error
	CloseAndRecv() (*PutObjectResponse, error)
	grpc.ClientStream
}

type dataproxyBackendServicePutObjectClient struct {
	grpc.ClientStream
}

func (x *dataproxyBackendServicePutObjectClient) Send(m *PutObjectRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataproxyBackendServicePutObjectClient) CloseAndRecv() (*PutObjectResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutObjectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataproxyBackendServiceClient) GetObject(ctx context.Context, in *GetObjectRequest, opts ...grpc.CallOption) (DataproxyBackendService_GetObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataproxyBackendService_ServiceDesc.Streams[1], DataproxyBackendService_GetObject_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &dataproxyBackendServiceGetObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataproxyBackendService_GetObjectClient interface {
	Recv() (*GetObjectResponse, error)
	grpc.ClientStream
}

type dataproxyBackendServiceGetObjectClient struct {
	grpc.ClientStream
}

func (x *dataproxyBackendServiceGetObjectClient) Recv() (*GetObjectResponse, error) {
	m := new(GetObjectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataproxyBackendServiceClient) HeadObject(ctx context.Context, in *HeadObjectRequest, opts ...grpc.CallOption) (*HeadObjectResponse, error) {
	out := new(HeadObjectResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_HeadObject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) InitMultiPartUpload(ctx context.Context, in *InitMultiPartUploadRequest, opts ...grpc.CallOption) (*InitMultiPartUploadResponse, error) {
	out := new(InitMultiPartUploadResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_InitMultiPartUpload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) UploadPart(ctx context.Context, opts ...grpc.CallOption) (DataproxyBackendService_UploadPartClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataproxyBackendService_ServiceDesc.Streams[2], DataproxyBackendService_UploadPart_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &dataproxyBackendServiceUploadPartClient{stream}
	return x, nil
}

type DataproxyBackendService_UploadPartClient interface {
	Send(*UploadPartRequest) error
	CloseAndRecv() (*UploadPartResponse, error)
	grpc.ClientStream
}

type dataproxyBackendServiceUploadPartClient struct {
	grpc.ClientStream
}

func (x *dataproxyBackendServiceUploadPartClient) Send(m *UploadPartRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataproxyBackendServiceUploadPartClient) CloseAndRecv() (*UploadPartResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadPartResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataproxyBackendServiceClient) CompleteMultiPartUpload(ctx context.Context, in *CompleteMultiPartUploadRequest, opts ...grpc.CallOption) (*CompleteMultiPartUploadResponse, error) {
	out := new(CompleteMultiPartUploadResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_CompleteMultiPartUpload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) CreateBucket(ctx context.Context, in *CreateBucketRequest, opts ...grpc.CallOption) (*CreateBucketResponse, error) {
	out := new(CreateBucketResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_CreateBucket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) DeleteBucket(ctx context.Context, in *DeleteBucketRequest, opts ...grpc.CallOption) (*DeleteBucketResponse, error) {
	out := new(DeleteBucketResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_DeleteBucket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) DeleteObject(ctx context.Context, in *DeleteObjectRequest, opts ...grpc.CallOption) (*DeleteObjectResponse, error) {
	out := new(DeleteObjectResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_DeleteObject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyBackendServiceClient) InitLocation(ctx context.Context, in *InitLocationRequest, opts ...grpc.CallOption) (*InitLocationResponse, error) {
	out := new(InitLocationResponse)
	err := c.cc.Invoke(ctx, DataproxyBackendService_InitLocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataproxyBackendServiceServer is the server API for DataproxyBackendService service.
// All implementations should embed UnimplementedDataproxyBackendServiceServer
// for forward compatibility
type DataproxyBackendServiceServer interface {
	PutObject(DataproxyBackendService_PutObjectServer) error
	GetObject(*GetObjectRequest, DataproxyBackendService_GetObjectServer) error
	HeadObject(context.Context, *HeadObjectRequest) (*HeadObjectResponse, error)
	InitMultiPartUpload(context.Context, *InitMultiPartUploadRequest) (*InitMultiPartUploadResponse, error)
	UploadPart(DataproxyBackendService_UploadPartServer) error
	CompleteMultiPartUpload(context.Context, *CompleteMultiPartUploadRequest) (*CompleteMultiPartUploadResponse, error)
	CreateBucket(context.Context, *CreateBucketRequest) (*CreateBucketResponse, error)
	DeleteBucket(context.Context, *DeleteBucketRequest) (*DeleteBucketResponse, error)
	DeleteObject(context.Context, *DeleteObjectRequest) (*DeleteObjectResponse, error)
	InitLocation(context.Context, *InitLocationRequest) (*InitLocationResponse, error)
}

// UnimplementedDataproxyBackendServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDataproxyBackendServiceServer struct {
}

func (UnimplementedDataproxyBackendServiceServer) PutObject(DataproxyBackendService_PutObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method PutObject not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) GetObject(*GetObjectRequest, DataproxyBackendService_GetObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method GetObject not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) HeadObject(context.Context, *HeadObjectRequest) (*HeadObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeadObject not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) InitMultiPartUpload(context.Context, *InitMultiPartUploadRequest) (*InitMultiPartUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitMultiPartUpload not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) UploadPart(DataproxyBackendService_UploadPartServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadPart not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) CompleteMultiPartUpload(context.Context, *CompleteMultiPartUploadRequest) (*CompleteMultiPartUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteMultiPartUpload not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) CreateBucket(context.Context, *CreateBucketRequest) (*CreateBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBucket not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) DeleteBucket(context.Context, *DeleteBucketRequest) (*DeleteBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBucket not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) DeleteObject(context.Context, *DeleteObjectRequest) (*DeleteObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteObject not implemented")
}
func (UnimplementedDataproxyBackendServiceServer) InitLocation(context.Context, *InitLocationRequest) (*InitLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitLocation not implemented")
}

// UnsafeDataproxyBackendServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataproxyBackendServiceServer will
// result in compilation errors.
type UnsafeDataproxyBackendServiceServer interface {
	mustEmbedUnimplementedDataproxyBackendServiceServer()
}

func RegisterDataproxyBackendServiceServer(s grpc.ServiceRegistrar, srv DataproxyBackendServiceServer) {
	s.RegisterService(&DataproxyBackendService_ServiceDesc, srv)
}

func _DataproxyBackendService_PutObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataproxyBackendServiceServer).PutObject(&dataproxyBackendServicePutObjectServer{stream})
}

type DataproxyBackendService_PutObjectServer interface {
	SendAndClose(*PutObjectResponse) error
	Recv() (*PutObjectRequest, error)
	grpc.ServerStream
}

type dataproxyBackendServicePutObjectServer struct {
	grpc.ServerStream
}

func (x *dataproxyBackendServicePutObjectServer) SendAndClose(m *PutObjectResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataproxyBackendServicePutObjectServer) Recv() (*PutObjectRequest, error) {
	m := new(PutObjectRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataproxyBackendService_GetObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetObjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataproxyBackendServiceServer).GetObject(m, &dataproxyBackendServiceGetObjectServer{stream})
}

type DataproxyBackendService_GetObjectServer interface {
	Send(*GetObjectResponse) error
	grpc.ServerStream
}

type dataproxyBackendServiceGetObjectServer struct {
	grpc.ServerStream
}

func (x *dataproxyBackendServiceGetObjectServer) Send(m *GetObjectResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DataproxyBackendService_HeadObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeadObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).HeadObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_HeadObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).HeadObject(ctx, req.(*HeadObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_InitMultiPartUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitMultiPartUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).InitMultiPartUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_InitMultiPartUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).InitMultiPartUpload(ctx, req.(*InitMultiPartUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_UploadPart_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataproxyBackendServiceServer).UploadPart(&dataproxyBackendServiceUploadPartServer{stream})
}

type DataproxyBackendService_UploadPartServer interface {
	SendAndClose(*UploadPartResponse) error
	Recv() (*UploadPartRequest, error)
	grpc.ServerStream
}

type dataproxyBackendServiceUploadPartServer struct {
	grpc.ServerStream
}

func (x *dataproxyBackendServiceUploadPartServer) SendAndClose(m *UploadPartResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataproxyBackendServiceUploadPartServer) Recv() (*UploadPartRequest, error) {
	m := new(UploadPartRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataproxyBackendService_CompleteMultiPartUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteMultiPartUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).CompleteMultiPartUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_CompleteMultiPartUpload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).CompleteMultiPartUpload(ctx, req.(*CompleteMultiPartUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_CreateBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).CreateBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_CreateBucket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).CreateBucket(ctx, req.(*CreateBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_DeleteBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).DeleteBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_DeleteBucket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).DeleteBucket(ctx, req.(*DeleteBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_DeleteObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).DeleteObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_DeleteObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).DeleteObject(ctx, req.(*DeleteObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyBackendService_InitLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyBackendServiceServer).InitLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyBackendService_InitLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyBackendServiceServer).InitLocation(ctx, req.(*InitLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataproxyBackendService_ServiceDesc is the grpc.ServiceDesc for DataproxyBackendService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataproxyBackendService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.dataproxy.services.v2.DataproxyBackendService",
	HandlerType: (*DataproxyBackendServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HeadObject",
			Handler:    _DataproxyBackendService_HeadObject_Handler,
		},
		{
			MethodName: "InitMultiPartUpload",
			Handler:    _DataproxyBackendService_InitMultiPartUpload_Handler,
		},
		{
			MethodName: "CompleteMultiPartUpload",
			Handler:    _DataproxyBackendService_CompleteMultiPartUpload_Handler,
		},
		{
			MethodName: "CreateBucket",
			Handler:    _DataproxyBackendService_CreateBucket_Handler,
		},
		{
			MethodName: "DeleteBucket",
			Handler:    _DataproxyBackendService_DeleteBucket_Handler,
		},
		{
			MethodName: "DeleteObject",
			Handler:    _DataproxyBackendService_DeleteObject_Handler,
		},
		{
			MethodName: "InitLocation",
			Handler:    _DataproxyBackendService_InitLocation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutObject",
			Handler:       _DataproxyBackendService_PutObject_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetObject",
			Handler:       _DataproxyBackendService_GetObject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UploadPart",
			Handler:       _DataproxyBackendService_UploadPart_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "aruna/api/dataproxy/services/v2/dataproxy_service.proto",
}

const (
	DataproxyUserService_GetCredentials_FullMethodName    = "/aruna.api.dataproxy.services.v2.DataproxyUserService/GetCredentials"
	DataproxyUserService_PushReplica_FullMethodName       = "/aruna.api.dataproxy.services.v2.DataproxyUserService/PushReplica"
	DataproxyUserService_PullReplica_FullMethodName       = "/aruna.api.dataproxy.services.v2.DataproxyUserService/PullReplica"
	DataproxyUserService_ReplicationStatus_FullMethodName = "/aruna.api.dataproxy.services.v2.DataproxyUserService/ReplicationStatus"
)

// DataproxyUserServiceClient is the client API for DataproxyUserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataproxyUserServiceClient interface {
	// GetCredentials
	//
	// Status: BETA
	//
	// Authorized method that needs a aruna-token to exchange for dataproxy
	// specific S3AccessKey and S3SecretKey
	GetCredentials(ctx context.Context, in *GetCredentialsRequest, opts ...grpc.CallOption) (*GetCredentialsResponse, error)
	// PushReplica
	//
	// Status: BETA
	//
	// Manually transfers a replica to another data-proxy
	PushReplica(ctx context.Context, in *PushReplicaRequest, opts ...grpc.CallOption) (*PushReplicaResponse, error)
	// PullReplica
	//
	// Status: BETA
	//
	// Manually request data to be transferred to this data-proxy
	PullReplica(ctx context.Context, in *PullReplicaRequest, opts ...grpc.CallOption) (*PullReplicaResponse, error)
	// PullReplica
	//
	// Status: BETA
	//
	// Status of the previous replication request
	ReplicationStatus(ctx context.Context, in *ReplicationStatusRequest, opts ...grpc.CallOption) (*ReplicationStatusResponse, error)
}

type dataproxyUserServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataproxyUserServiceClient(cc grpc.ClientConnInterface) DataproxyUserServiceClient {
	return &dataproxyUserServiceClient{cc}
}

func (c *dataproxyUserServiceClient) GetCredentials(ctx context.Context, in *GetCredentialsRequest, opts ...grpc.CallOption) (*GetCredentialsResponse, error) {
	out := new(GetCredentialsResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_GetCredentials_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyUserServiceClient) PushReplica(ctx context.Context, in *PushReplicaRequest, opts ...grpc.CallOption) (*PushReplicaResponse, error) {
	out := new(PushReplicaResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_PushReplica_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyUserServiceClient) PullReplica(ctx context.Context, in *PullReplicaRequest, opts ...grpc.CallOption) (*PullReplicaResponse, error) {
	out := new(PullReplicaResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_PullReplica_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataproxyUserServiceClient) ReplicationStatus(ctx context.Context, in *ReplicationStatusRequest, opts ...grpc.CallOption) (*ReplicationStatusResponse, error) {
	out := new(ReplicationStatusResponse)
	err := c.cc.Invoke(ctx, DataproxyUserService_ReplicationStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataproxyUserServiceServer is the server API for DataproxyUserService service.
// All implementations should embed UnimplementedDataproxyUserServiceServer
// for forward compatibility
type DataproxyUserServiceServer interface {
	// GetCredentials
	//
	// Status: BETA
	//
	// Authorized method that needs a aruna-token to exchange for dataproxy
	// specific S3AccessKey and S3SecretKey
	GetCredentials(context.Context, *GetCredentialsRequest) (*GetCredentialsResponse, error)
	// PushReplica
	//
	// Status: BETA
	//
	// Manually transfers a replica to another data-proxy
	PushReplica(context.Context, *PushReplicaRequest) (*PushReplicaResponse, error)
	// PullReplica
	//
	// Status: BETA
	//
	// Manually request data to be transferred to this data-proxy
	PullReplica(context.Context, *PullReplicaRequest) (*PullReplicaResponse, error)
	// PullReplica
	//
	// Status: BETA
	//
	// Status of the previous replication request
	ReplicationStatus(context.Context, *ReplicationStatusRequest) (*ReplicationStatusResponse, error)
}

// UnimplementedDataproxyUserServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDataproxyUserServiceServer struct {
}

func (UnimplementedDataproxyUserServiceServer) GetCredentials(context.Context, *GetCredentialsRequest) (*GetCredentialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCredentials not implemented")
}
func (UnimplementedDataproxyUserServiceServer) PushReplica(context.Context, *PushReplicaRequest) (*PushReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushReplica not implemented")
}
func (UnimplementedDataproxyUserServiceServer) PullReplica(context.Context, *PullReplicaRequest) (*PullReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullReplica not implemented")
}
func (UnimplementedDataproxyUserServiceServer) ReplicationStatus(context.Context, *ReplicationStatusRequest) (*ReplicationStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplicationStatus not implemented")
}

// UnsafeDataproxyUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataproxyUserServiceServer will
// result in compilation errors.
type UnsafeDataproxyUserServiceServer interface {
	mustEmbedUnimplementedDataproxyUserServiceServer()
}

func RegisterDataproxyUserServiceServer(s grpc.ServiceRegistrar, srv DataproxyUserServiceServer) {
	s.RegisterService(&DataproxyUserService_ServiceDesc, srv)
}

func _DataproxyUserService_GetCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).GetCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_GetCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).GetCredentials(ctx, req.(*GetCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyUserService_PushReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).PushReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_PushReplica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).PushReplica(ctx, req.(*PushReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyUserService_PullReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).PullReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_PullReplica_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).PullReplica(ctx, req.(*PullReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataproxyUserService_ReplicationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataproxyUserServiceServer).ReplicationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataproxyUserService_ReplicationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataproxyUserServiceServer).ReplicationStatus(ctx, req.(*ReplicationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataproxyUserService_ServiceDesc is the grpc.ServiceDesc for DataproxyUserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataproxyUserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aruna.api.dataproxy.services.v2.DataproxyUserService",
	HandlerType: (*DataproxyUserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCredentials",
			Handler:    _DataproxyUserService_GetCredentials_Handler,
		},
		{
			MethodName: "PushReplica",
			Handler:    _DataproxyUserService_PushReplica_Handler,
		},
		{
			MethodName: "PullReplica",
			Handler:    _DataproxyUserService_PullReplica_Handler,
		},
		{
			MethodName: "ReplicationStatus",
			Handler:    _DataproxyUserService_ReplicationStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aruna/api/dataproxy/services/v2/dataproxy_service.proto",
}
